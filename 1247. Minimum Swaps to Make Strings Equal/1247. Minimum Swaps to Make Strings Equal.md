1247. Minimum Swaps to Make Strings Equal
-----------------------------------------
1247. 交换字符使得字符串相同
-----------------------------------------

根据题意，s1和s2不相等的位置有两种可能，s1该位置为'x'，s2该位置为'y'，或者相反。而要通过交换字符使s1和s2相等，则至少应该有两个不相等位置的字符来相互交换，如果只有一个位置不相等，则无法通过交换使s1和s2相等。  
如果有两处位置不相等，则其可能性有如下4种：
\ | s1    | s2    
|-|-|-|
1| x x   | y y   
2| x y   | y x   
3| y y   | x x   
4| y x   | x y  

其中第一种组合，在交换s1的第二个x和s2的第一个y之后，可以变为 x y | x y，即相等状态。同理，第三种组合也可以通过一次交换变为相等状态。而第二/四种组合可以通过一次交换转化为第一/三种组合。所以所有交换次数等于第一种组合的数量加第三种组合的数量，在加上第二和第四种组合数量的两倍。   

    C = C1 + C3 + 2 * (C2 + C4)

而C1实际为s1在不相等位置上x的数量除以2，C3为s1在不相等位置上y的个数除以2，余下的不相等为位置用于构成第二/四中组合，显然(C2 + C4)最大为1.  

综上，本题整体算法思路如下：  
1. 遍历比较s1和s2的所有位置，记录s1中不相等位置上的x和y的数量Cx/Cy；
2. 如果不相等位置为奇数，则返回-1（无法通过交换使s1/s2相等）；
3. 计算交换次数 Cx/2 + Cy/2 + Cx%2 + Cy%2

代码如下，时间复杂度O(n)，空间复杂度O(1) :  

    def minimumSwap(self, s1: str, s2: str) -> int:

        x_cnt = y_cnt = 0

        for i in range(len(s1)) :
            if s1[i] == s2[i] :
                continue
            
            if s1[i] == 'x' :
                x_cnt += 1
            else :
                y_cnt += 1
            
        if (x_cnt + y_cnt) % 2 :
            return -1

        return x_cnt // 2 + y_cnt // 2 + x_cnt % 2 + y_cnt % 2